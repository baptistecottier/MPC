/**
  * \file cmp_steps.c
  * \brief implementation of the functions used for the comparison
*/
#include <string.h>
#include "cmp_steps.h"

/**
  * \fn void step1_init(mpz_t Alice, mpz_t y, uint8_t * Alice_input)
  * \brief This function imports mpz_t values from bytes arrays and allocates memory

  * \param[out] Alice       mpz_t representing Alice's input
  * \param[out] y           mpz_t representing the random value generated by Alice

  * \param[in] Alice_input  bytes vector representing Alice's input
*/
void step1_init(mpz_t Alice, mpz_t y, uint8_t * Alice_input) {
  mpz_inits(Alice,y, NULL);
  mpz_import(Alice,1,-1,bits_to_bytes(PARAM_L),0,0,Alice_input);
  gmp_printf("( %Zu < ",Alice);
}

/**
  * \fn void step1_clear(uint8_t * ct_Alice, uint8_t * sen_y, mpz_t Alice, mpz_t y)
  * \brief This function exports mpz_t values to bytes arrays and clear allocated memory

  * \param[out] ct_Alice  bytes array representing Alice's input ciphertext
  * \param[out] sen_y     bytes array representing the random value generated by Alice

  * \param[in] Alice      mpz_t representing Alice's input
  * \param[in] y          mpz_t representing the random value generated by Alice

*/
void step1_clear(uint8_t * ct_Alice, uint8_t * sen_y, mpz_t Alice, mpz_t y) {
  mpz_export(ct_Alice,NULL,-1,1,0,0,Alice);
  mpz_export(sen_y,NULL,-1,1,0,0,y);
  mpz_clears(Alice,y,NULL);
}

/**
  * \fn void cmp_Alice_step1(Alice_struct * Alice, OT_sender * Alice_OT, uint8_t * Alice_input)
  * \brief This function gathers subfunctions used by Alice in the first step

  * \param[out] Alice       Alice_struct stocking Alice's Values
  * \param[out] Alice_OT s  OT_sender stocking Alice's values for the oblivious transfer

  * \param[in] Alice_input  bytes array representing Alice's input
*/
void cmp_Alice_step1(Alice_struct * Alice, OT_sender * Alice_OT, uint8_t * Alice_input) {

  mpz_t mpz_Alice, mpz_y;
  step1_init(mpz_Alice, mpz_y, Alice_input);

  paillier_encrypt(mpz_Alice,mpz_Alice);
  OT_sender_setup(Alice_OT->sen_enc_S, mpz_y,Alice_OT->sen_S,Alice_OT->sen_T);

  step1_clear(Alice->ct_Alice,Alice_OT->sen_y,mpz_Alice,mpz_y);
}

/**
  * \fn void step2_init(mpz_t * x, mpz_t mpz_Bob, mpz_t ct_Alice, mpz_t rho, mpz_t ct_gamma, Bob_struct * Bob, uint8_t * Bob_input)
  * \brief This function imports mpz_t values from bytes arrays and allocates memory

  * \param[out] x         mpz_t array representing the random values generated by Bob
  * \param[out] mpz_Bob   mpz_t representing Bob's input
  * \param[out] ct_Alice  mpz_t representing Alice's input ciphertext
  * \param[out] rho       mpz_t representing the random new input generated by Bob
  * \param[out] ct_gamma  mpz_t representing the new Alice's input ciphertext

  * \param[in] Bob        Bob_struct stocking Bob's values
  * \param[in] Bob_input  bytes array representing Bob's input
*/
void step2_init(mpz_t * x, mpz_t mpz_Bob, mpz_t ct_Alice, mpz_t rho, mpz_t ct_gamma, Bob_struct * Bob, uint8_t * Bob_input) {

  mpz_inits(mpz_Bob, ct_Alice, rho, ct_gamma,NULL);
  for (int i = 0; i < PARAM_L+1; ++i) mpz_init(x[i]);

  mpz_import(mpz_Bob,1,-1,bits_to_bytes(PARAM_L),0,0,Bob_input);
  mpz_import(ct_Alice,1,-1,PAILLIER_KEY_SIZE/4,0,0,Bob->ct_Alice);

  gmp_printf("%Zu ) = ",mpz_Bob);
}

/**
  * \fn void step2_clear(Bob_struct * Bob, OT_receiver * Bob_OT, mpz_t * x, mpz_t mpz_Bob, mpz_t ct_Alice, mpz_t rho, mpz_t ct_gamma)
  * \brief This function exports mpz_t values to bytes arrays and clear allocated memory

  * \param[out] x         mpz_t array representing the random values generated by Bob
  * \param[out] mpz_Bob   mpz_t representing Bob's input
  * \param[out] ct_Alice  mpz_t representing Alice's input ciphertext
  * \param[out] rho       mpz_t representing the random new input generated by Bob
  * \param[out] ct_gamma  mpz_t representing the new Alice's input ciphertext

  * \param[in] Bob        Bob_struct stocking Bob's values
  * \param[in] Bob_OT     OT_sender representing Bob's values for the oblivious transfers
*/
void step2_clear(Bob_struct * Bob, OT_receiver * Bob_OT, mpz_t * x, mpz_t mpz_Bob, mpz_t ct_Alice, mpz_t rho, mpz_t ct_gamma) {
  mpz_export(Bob->rho,NULL,-1,1,0,0,rho);
  mpz_export(Bob->ct_gamma,NULL,-1,1,0,0,ct_gamma);
  for (int i=0 ; i < PARAM_L +1 ;i++ ) {
    mpz_export(Bob_OT->rec_x[i],NULL,-1,1,0,0,x[i]);
    mpz_clear(x[i]);
  }
  mpz_clears(mpz_Bob, ct_Alice, rho, ct_gamma,NULL);
  free(x);
}

/**
  * \fn void cmp_Bob_step2(Bob_struct * Bob, OT_receiver * Bob_OT, uint8_t * Bob_input)
  * \brief This function gathers subfunctions used by Bob in the second step

  * \param[out] Bob       Bob_struct stocking Bob's Values
  * \param[out] Bob_OT    OT_receiver stocking Bob's values for the oblivious transfer

  * \param[in] Bob_input Bob's input
*/
void cmp_Bob_step2(Bob_struct * Bob, OT_receiver * Bob_OT, uint8_t * Bob_input) {

  mpz_t * x=calloc(PARAM_L+1,sizeof(mpz_t));
  mpz_t mpz_Bob , mpz_ct_Alice , mpz_rho , mpz_ct_gamma;

  step2_init(x, mpz_Bob, mpz_ct_Alice, mpz_rho, mpz_ct_gamma, Bob, Bob_input);

  cmp_Bob_gen_inputs(mpz_ct_gamma,mpz_rho,mpz_ct_Alice, mpz_Bob);
  OT_receiver_choose(Bob_OT->rec_enc_R,x,Bob_OT->rec_R,Bob_OT->rec_enc_S,mpz_rho);

  step2_clear(Bob, Bob_OT, x, mpz_Bob, mpz_ct_Alice, mpz_rho, mpz_ct_gamma);
}

/**
  * \fn void step3_init(mpz_t gamma, mpz_t ct_gamma, mpz_t y, mpz_t ** keys, mpz_t ** kA, mpz_t ** kB, mpz_t ** ct_AND, mpz_t * input_keys, mpz_t * trans_table, Alice_struct * Alice, OT_sender * Alice_OT)
  * \brief This function imports mpz_t values from bytes arrays and allocates memory

  * \param[out] gamma       mpz_t representing Alice's new input
  * \param[out] ct_gamma    mpz_t representing Alice's new input ciphertext
  * \param[out] y           mpz_t representing the random value generated by Alice
  * \param[out] keys        mpz_t double array representing the keys generated during the oblivious transfers
  * \param[out] kA          mpz_t double array representing Alice's input keys
  * \param[out] kB          mpz_t double array representing Bob's input keys
  * \param[out] ct_AND      mpz_t double array representing the ciphertexts for the AND gates
  * \param[out] input_keys  mpz_t array representing the Alice's input keys sent to Bob
  * \param[out] trans_table mpz_t array representing the translation table

  * \param[in] Alice       Alice_struct stocking Alice's Values
  * \param[in] Alice_OT s  OT_sender stocking Alice's values for the oblivious transfer
*/
void step3_init(mpz_t gamma, mpz_t ct_gamma, mpz_t y, mpz_t ** keys, mpz_t ** kA, mpz_t ** kB, mpz_t ** ct_AND, mpz_t * input_keys, mpz_t * trans_table, Alice_struct * Alice, OT_sender * Alice_OT) {
  mpz_inits(gamma, ct_gamma, y,NULL);
  mpz_import(ct_gamma,1,-1,PAILLIER_KEY_SIZE/4,0,0,Alice->ct_gamma);
  mpz_import(y,1,-1,bits_to_bytes(255),0,0,Alice_OT->sen_y);

  for (int i=0;i<PARAM_L;i++) {
    keys[i]=calloc(2,sizeof(mpz_t));
    kA[i]=calloc(2,sizeof(mpz_t));
    kB[i]=calloc(2,sizeof(mpz_t));
    ct_AND[i]=calloc(2,sizeof(mpz_t));
    mpz_inits(keys[i][0],keys[i][1],kA[i][0],kA[i][1],kB[i][0],kB[i][1],ct_AND[i][0],ct_AND[i][1],input_keys[i],NULL);
  }

  keys[PARAM_L]=calloc(2,sizeof(mpz_t));
  kA[PARAM_L]=calloc(2,sizeof(mpz_t));
  kB[PARAM_L]=calloc(2,sizeof(mpz_t));
  mpz_inits(kA[PARAM_L][0],kA[PARAM_L][1],kB[PARAM_L][0],kB[PARAM_L][1],input_keys[PARAM_L],keys[PARAM_L][0],keys[PARAM_L][1],NULL);
  mpz_inits(trans_table[0],trans_table[1],NULL);
}

/**
  * \fn void step3_clear(Alice_struct * Alice, OT_sender * Alice_OT, mpz_t gamma, mpz_t ct_gamma, mpz_t y, mpz_t ** keys, mpz_t ** kA, mpz_t ** kB, mpz_t ** ct_AND, mpz_t * input_keys, mpz_t * trans_table)
  * \brief This function exports mpz_t values to bytes arrays and allocates memory

  * \param[out] Alice       Alice_struct stocking Alice's Values
  * \param[out] Alice_OT s  OT_sender stocking Alice's values for the oblivious transfer

  * \param[in] gamma       mpz_t representing Alice's new input
  * \param[in] ct_gamma    mpz_t representing Alice's new input ciphertext
  * \param[in] y           mpz_t representing the random value generated by Alice
  * \param[in] keys        mpz_t double array representing the keys generated during the oblivious transfers
  * \param[in] kA          mpz_t double array representing Alice's input keys
  * \param[in] kB          mpz_t double array representing Bob's input keys
  * \param[in] ct_AND      mpz_t double array representing the ciphertexts for the AND gates
  * \param[in] input_keys  mpz_t array representing the Alice's input keys sent to Bob
  * \param[in] trans_table mpz_t array representing the translation table

*/
void step3_clear(Alice_struct * Alice, OT_sender * Alice_OT, mpz_t gamma, mpz_t ct_gamma, mpz_t y, mpz_t ** keys, mpz_t ** kA, mpz_t ** kB, mpz_t ** ct_AND, mpz_t * input_keys, mpz_t * trans_table) {

  for (int i=0 ; i<2*PARAM_L ; i++) mpz_export(Alice->ct_AND[i/2][i%2],NULL,-1,1,0,0,ct_AND[i/2][i%2]);

  mpz_export(Alice->trans_table[0],NULL,-1,1,0,0,trans_table[0]);
  mpz_export(Alice->trans_table[1],NULL,-1,1,0,0,trans_table[1]);
  for (int i=0 ; i<PARAM_L+1; i++) for(int j=0;j<2;j++) mpz_export(Alice_OT->sen_keys[i][j],NULL,-1,1,0,0,keys[i][j]);

  mpz_clears(trans_table[0],trans_table[1],NULL);
  mpz_clears(gamma, ct_gamma, y,NULL);
  for (int i=0 ; i<PARAM_L ; i++) {
    mpz_clears(keys[i][0],keys[i][1],kA[i][0],kA[i][1],kB[i][0],kB[i][1],ct_AND[i][0],ct_AND[i][1],input_keys[i],NULL);
    free(kA[i]);
    free(kB[i]);
    free(keys[i]);
    free(ct_AND[i]);
  }
  mpz_clears(kA[PARAM_L][0],kA[PARAM_L][1],kB[PARAM_L][0],kB[PARAM_L][1],input_keys[PARAM_L],keys[PARAM_L][0],keys[PARAM_L][1],NULL);
  free(keys[PARAM_L]);
  free(kA[PARAM_L]);
  free(kB[PARAM_L]);
  free(keys);
  free(kA);
  free(kB);
  free(ct_AND);
  free(input_keys);
  free(trans_table);
}

/**
  * \fn int cmp_Alice_step3(Alice_struct * Alice, OT_sender * Alice_OT)
  * \brief This function gathers subfunctions used by Alice in the third step

  * \param[out] Alice variable stocking Alice's Values
  * \param[out] Alice_OT s variable stocking ALice's values for the oblivious transfer
*/
int cmp_Alice_step3(Alice_struct * Alice, OT_sender * Alice_OT) {

  mpz_t mpz_gamma, mpz_ct_gamma, mpz_y;
  mpz_t ** mpz_keys=calloc(PARAM_L+1,sizeof(mpz_t*));
  mpz_t ** kA=calloc(PARAM_L+1,sizeof(mpz_t *));
  mpz_t ** kB=calloc(PARAM_L+1,sizeof(mpz_t *));
  mpz_t ** mpz_ct_AND=calloc(PARAM_L,sizeof(mpz_t*));
  mpz_t * mpz_input_keys=calloc(PARAM_L+1,sizeof(mpz_t));
  mpz_t * mpz_trans_table=calloc(2,sizeof(mpz_t));


  step3_init(mpz_gamma, mpz_ct_gamma, mpz_y, mpz_keys, kA, kB, mpz_ct_AND, mpz_input_keys, mpz_trans_table, Alice, Alice_OT);

  paillier_decrypt(mpz_gamma, mpz_ct_gamma);
  cmp_Alice_garbling(kA,kB,mpz_trans_table,mpz_ct_AND);
  OT_sender_key_derivation(mpz_keys,kB,Alice_OT->sen_enc_R,Alice_OT->sen_T,mpz_y);
  cmp_Alice_set_keys(Alice->Alice_keys, kA, mpz_gamma);

  step3_clear(Alice, Alice_OT, mpz_gamma, mpz_ct_gamma, mpz_y, mpz_keys, kA, kB, mpz_ct_AND, mpz_input_keys, mpz_trans_table);

  return 0 ;
}

/**
  * \fn void step4_init(mpz_t rho, mpz_t * x, mpz_t * trans_table, mpz_t ** ct_AND, mpz_t * Bob_keys, mpz_t * Alice_keys, mpz_t ** keys, Bob_struct * Bob, OT_receiver * Bob_OT)
  * \brief This function imports mpz_t values from bytes arrays and allocates memory


  * \param[out] rho         mpz_t representing the random new input generated by Bob
  * \param[out] x           mpz_t array representing the random values generated by Bob
  * \param[out] trans_table mpz_t array representing the translation table
  * \param[out] ct_AND      mpz_t double array representing the ciphertexts for the AND gates
  * \param[out] Bob_keys    mpz_t array representing the Bob's input keys
  * \param[out] Alice_keys  mpz_t array representing the Alice's input keys
  * \param[out] keys        mpz_t double array representing the keys generated during the oblivious transfers

  * \param[in] Bob          Bob_struct stocking Bob's values
  * \param[in] Bob_OT       OT_receiver stocking Bob's values for the oblivious transfers
*/
void step4_init(mpz_t rho, mpz_t * x, mpz_t * trans_table, mpz_t ** ct_AND, mpz_t * Bob_keys, mpz_t * Alice_keys, mpz_t ** keys, Bob_struct * Bob, OT_receiver * Bob_OT) {
  mpz_inits(rho,trans_table[0],trans_table[1],NULL);

  for (int i=0 ; i<PARAM_L+1 ; i++) {

  	keys[i]=calloc(2,sizeof(mpz_t));
    mpz_inits(Alice_keys[i],Bob_keys[i],x[i],keys[i][0],keys[i][1],NULL);
    mpz_import(Alice_keys[i],1,-1,bits_to_bytes(KEY_SIZE),0,0,Bob->Alice_keys[i]);
    mpz_import(x[i],1,-1,32,0,0,Bob_OT->rec_x[i]);
  	mpz_import(keys[i][0],1,-1,bits_to_bytes(KEY_SIZE),0,0,Bob_OT->rec_keys[i][0]);
  	mpz_import(keys[i][1],1,-1,bits_to_bytes(KEY_SIZE),0,0,Bob_OT->rec_keys[i][1]);
  	mpz_import(trans_table[0],1,-1,bits_to_bytes(KEY_SIZE),0,0,Bob->trans_table[0]);
  	mpz_import(trans_table[1],1,-1,bits_to_bytes(KEY_SIZE),0,0,Bob->trans_table[1]);

  	if (i<PARAM_L) {
  		ct_AND[i]=calloc(2,sizeof(mpz_t));
  		for (int j=0 ; j<2 ; j++ ) {
  			mpz_init(ct_AND[i][j]);
  			mpz_import(ct_AND[i][j],1,-1,bits_to_bytes(KEY_SIZE),0,0,Bob->ct_AND[i][j]);
  		}
  	}
  }

  for (int i=0 ; i<2 ;i++) mpz_import(trans_table[i],1,-1,bits_to_bytes(KEY_SIZE),0,0,Bob->trans_table[i]);

  mpz_import(rho,1,-1,bits_to_bytes(PARAM_L+PARAM_K),0,0,Bob->rho);
}

/**
  * \fn void step4_clear(Bob_struct * Bob, OT_receiver * Bob_OT, mpz_t rho, mpz_t * x, mpz_t * trans_table, mpz_t ** ct_AND, mpz_t * Bob_keys, mpz_t * Alice_keys, mpz_t ** keys)
  * \brief This function exports mpz_t values to bytes arrays and allocates memory

  * \param[out] Bob        Bob_struct stocking Bob's values
  * \param[out] Bob_OT     OT_receiver stocking Bob's values for the oblivious transfers

  * \param[in] rho         mpz_t representing the random new input generated by Bob
  * \param[in] x           mpz_t array representing the random values generated by Bob
  * \param[in] trans_table mpz_t array representing the translation table
  * \param[in] ct_AND      mpz_t double array representing the ciphertexts for the AND gates
  * \param[in] Bob_keys    mpz_t array representing the Bob's input keys
  * \param[in] Alice_keys  mpz_t array representing the Alice's input keys
  * \param[in] keys        mpz_t double array representing the keys generated during the oblivious transfers
*/
void step4_clear(Bob_struct * Bob, OT_receiver * Bob_OT, mpz_t rho, mpz_t * x, mpz_t * trans_table, mpz_t ** ct_AND, mpz_t * Bob_keys, mpz_t * Alice_keys, mpz_t ** keys) {
  for (int i=0 ; i<PARAM_L+1 ; i++) {
    mpz_clears(Alice_keys[i],Bob_keys[i],x[i],keys[i][0],keys[i][1],NULL);
    free(keys[i]);
    if (i<PARAM_L) {
     mpz_clears(ct_AND[i][0],ct_AND[i][1],NULL);
  	 	free(ct_AND[i]);
  	}
  }
  mpz_clears(rho,trans_table[0],trans_table[1],NULL);
  free(x);
  free(trans_table);
  free(ct_AND);
  free(Bob_keys);
  free(Alice_keys);
  free(keys);
}

/**
  * \fn int cmp_Bob_step4(Bob_struct * Bob, OT_receiver * Bob_OT)
  * \brief This function gathers subfunctions used by Bob in the fourth step

  * \param[out] Bob variable stocking Bob's Values
  * \param[out] Bob_OT s variable stocking Bob's values for the oblivious transfer
*/
int cmp_Bob_step4(Bob_struct * Bob , OT_receiver * Bob_OT) {

  int result;
  mpz_t mpz_rho;
  mpz_t * mpz_x=calloc(PARAM_L+1,sizeof(mpz_t));
  mpz_t * mpz_trans_table=calloc(2,sizeof(mpz_t));
  mpz_t ** mpz_ct_AND=calloc(PARAM_L,sizeof(mpz_t*));
  mpz_t * mpz_Bob_keys=calloc(PARAM_L+1,sizeof(mpz_t));
  mpz_t * mpz_Alice_keys=calloc(PARAM_L+1,sizeof(mpz_t));
  mpz_t ** mpz_keys=calloc(PARAM_L+1,sizeof(mpz_t*));

  step4_init(mpz_rho, mpz_x, mpz_trans_table, mpz_ct_AND, mpz_Bob_keys, mpz_Alice_keys, mpz_keys, Bob, Bob_OT);

  OT_receiver_retrieve(mpz_Bob_keys,mpz_keys,mpz_x,Bob_OT->rec_enc_S,mpz_rho);

  result=cmp_Bob_eval(mpz_Alice_keys, mpz_Bob_keys, mpz_ct_AND, mpz_trans_table);
  if (result==-1) {
    printf("Error : no match in the translation table\n");
    return -1 ;
  }
  if (PARAM_INEQ%2==1) result=1-result;

  step4_clear(Bob, Bob_OT, mpz_rho, mpz_x, mpz_trans_table, mpz_ct_AND, mpz_Bob_keys, mpz_Alice_keys, mpz_keys);

  return result;
}
